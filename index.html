<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Galaxy Animation - Complete</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* Estilos originales del título */
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .title h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-weight: 300;
            letter-spacing: 2px;
        }
        .title .author {
            font-size: 0.8em;
            opacity: 0.7;
            margin: 5px 0 0 0;
        }
        
        /* Estilos originales de estadísticas */
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            backdrop-filter: blur(5px);
        }
        .stats div {
            margin: 5px 0;
            opacity: 0.9;
        }
        
        /* Estilos originales de controles */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        .control-button {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            backdrop-filter: blur(5px);
            min-width: 100px;
            text-align: center;
            white-space: nowrap;
        }
        .control-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .control-button.activate-button.resonance-active {
            border-color: #ff6b35;
            background: rgba(255, 107, 53, 0.2);
        }
        .control-button.activate-button.resonance-active:hover {
            background: rgba(255, 107, 53, 0.4);
        }
        .control-button.resonance-active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.3);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
            max-height: 150px;
            overflow-y: auto;
            display: none; /* Ocultar por defecto, presiona 'D' para mostrar */
        }
        .debug-error { color: #ff6666; }
        .debug-success { color: #66ff66; }
        .debug-info { color: #66ccff; }
        .debug-warning { color: #ffaa66; }

    </style>
</head>
<body>
    <div id="container"></div>
    
    <!-- Indicadores de estado originales -->
    <div class="stats" id="stats">
        <div>Systems: Active</div>
        <div>Resonance: Stable</div>
        <div>Phase: Nominal</div>
    </div>
    
    <!-- Título original -->
    <div class="title">
        <h1>Solar System</h1>
        <p class="author">by Mikeblackhat</p>
    </div>
    
    <!-- Controles originales -->
    <div class="controls">
        <button class="control-button" id="resetView">Reset View</button>
        <button class="control-button activate-button" id="activateTrigger">Activate Resonance</button>
        <button class="control-button" id="timeAccel">Time: 1x</button>
        <button class="control-button" id="toggleTheme">Theme: Celestial</button>

    </div>
    
    <div id="debug-panel">
        <div>Estado: <span id="debug-state">Iniciando...</span></div>
        <div id="debug-messages"></div>
    </div>

    
    <!-- Shaders -->
    <script id="starVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main(){
            vPosition = position;
            vNormal = normal;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <script id="starFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform float intensity;
        uniform vec3 color1;
        uniform vec3 color2;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        
        float noise(vec3 p){
            return fract(sin(dot(p, vec3(12.9898, 78.233, 54.53))) * 43758.5453);
        }
        
        void main(){
            vec3 pos = vPosition + time * 0.1;
            float n1 = noise(pos * 3.0);
            float n2 = noise(pos * 6.0 + vec3(100.0));
            float n3 = noise(pos * 12.0 + vec3(200.0));
            float pattern = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
            pattern = pow(pattern, 2.0);
            vec3 finalColor = mix(color1, color2, pattern);
            finalColor *= (1.0 + intensity * pattern * 2.0);
            float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
            finalColor += fresnel * intensity * 0.5;
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>
    
    <script id="planetVertexShader" type="x-shader/x-vertex">
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        void main(){
            vPosition = position;
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <script id="planetFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 accentColor;
        uniform float energy;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec2 vUv;
        
        float noise(vec2 p){
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        
        void main(){
            vec2 uv = vUv + time * 0.02;
            float n1 = noise(uv * 8.0);
            float n2 = noise(uv * 16.0);
            float pattern = n1 * 0.7 + n2 * 0.3;
            vec3 color = mix(baseColor, accentColor, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
            color += fresnel * accentColor * 0.5;
            color *= (1.0 + energy * 0.8);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    
    <script id="bigBangVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        
        void main(){
            vUv = uv;
            vPosition = position;
            vec3 pos = position;
            float expansion = sin(time * 5.0) * 0.5 + 0.5;
            pos *= (1.0 + expansion * 3.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>
    
    <script id="bigBangFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 center;
        uniform float explosionRadius;
        varying vec2 vUv;
        varying vec3 vPosition;
        
        float noise(vec3 p){
            return fract(sin(dot(p, vec3(12.9898, 78.233, 54.53))) * 43758.5453);
        }
        
        void main(){
            vec3 pos = vPosition - center;
            float dist = length(pos);
            float wave = sin(dist * 10.0 - time * 15.0);
            float explosion = 1.0 - smoothstep(0.0, explosionRadius, dist);
            float n = noise(pos * 5.0 + time * 3.0);
            
            vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(0.2, 0.1, 0.8), n);
            color *= (1.0 + wave * 0.5) * explosion;
            
            float alpha = explosion * (0.8 + wave * 0.2);
            gl_FragColor = vec4(color, alpha);
        }
    </script>
    
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
      }
    }
    </script>
    
    <script type="module">
        // Sistema de depuración
        const debugPanel = document.getElementById('debug-panel');
        const debugState = document.getElementById('debug-state');
        const debugMessages = document.getElementById('debug-messages');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `debug-${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugMessages.appendChild(div);
            debugMessages.scrollTop = debugMessages.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function setState(state) {
            debugState.textContent = state;
            debugState.className = state.toLowerCase().includes('error') ? 'debug-error' : 'debug-success';
        }
        
        try {
            log('=== INICIANDO GALAXIA 3D COMPLETA ===', 'info');
            setState('Cargando módulos...');
            
            // Importar Three.js y addons
            const THREE = await import('three');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            const { EffectComposer } = await import('three/addons/postprocessing/EffectComposer.js');
            const { RenderPass } = await import('three/addons/postprocessing/RenderPass.js');
            const { UnrealBloomPass } = await import('three/addons/postprocessing/UnrealBloomPass.js');
            
            log('Todos los módulos cargados ✓', 'success');
            
            // Verificar container
            setState('Verificando DOM...');
            const container = document.getElementById('container');
            if (!container) throw new Error('Container no encontrado');
            log('Container verificado ✓', 'success');
            
            // Variables globales
            let scene, camera, renderer, composer, controls;
            let star, planets = [], comets = [], bigBangEffect;
            let timeAcceleration = 1;
            let currentTheme = 'Celestial';
            let resonanceActive = false;
            const clock = new THREE.Clock();
            // Gestores de naves y asteroides eliminados del sistema
            // Configuración de visibilidad de naves y asteroides eliminada
            // Variables para naves y asteroides eliminadas
            
            // Definir temas con colores realistas de planetas
            const themes = {
                Inferno: {
                    background: 0x0a0a0a,
                    star: 0xff4500,
                    planets: [
                        0x8c7853, // Mercurio - grisáceo marrón
                        0xffc649, // Venus - amarillo dorado
                        0x6b93d6, // Tierra - azul océano
                        0xcd5c5c, // Marte - rojo oxidado
                        0xd8ca9d, // Júpiter - beige con bandas
                        0xfad5a5, // Saturno - amarillo pálido
                        0x4fd0e7  // Urano - azul verdoso
                    ],
                    ambient: 0x1a1a1a,
                    point: 0xff4500
                },
                Veridian: {
                    background: 0x0a1a0a,
                    star: 0x44ff88,
                    planets: [
                        0x8c7853, // Mercurio - grisáceo marrón
                        0xffc649, // Venus - amarillo dorado  
                        0x4a90e2, // Tierra - azul más vibrante
                        0xe74c3c, // Marte - rojo más intenso
                        0xe6d690, // Júpiter - amarillo dorado
                        0xf4e4bc, // Saturno - crema
                        0x50e3c2  // Urano - turquesa
                    ],
                    ambient: 0x1a2a1a,
                    point: 0x44ff88
                },
                Celestial: {
                    background: 0x0a0a1a,
                    star: 0xffe4b5,
                    planets: [
                        0x8b8680, // Mercurio - gris oscuro
                        0xffd700, // Venus - oro puro
                        0x4169e1, // Tierra - azul real
                        0xdc143c, // Marte - carmesí
                        0xdaa520, // Júpiter - oro viejo
                        0xf5deb3, // Saturno - trigo
                        0x40e0d0  // Urano - turquesa medio
                    ],
                    ambient: 0x1a1a2a,
                    point: 0xffe4b5
                }
            };
            
            // Funciones principales
            function createScene() {
                log('Creando escena...', 'info');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(themes[currentTheme].background);
                log('Escena creada ✓', 'success');
            }
            
            function createCamera() {
                log('Creando cámara...', 'info');
                camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
                // Posicionar la cámara más cerca del área del título con vista completa del sistema solar
            // Calcular distancia para abarcar todos los planetas
            const solarSystemRadius = planets.length > 0 ? 
                Math.max(...planets.map(p => p.distance)) + 5 : 40;
            
            // Posición más cercana y baja para estar más abajo
            camera.position.set(solarSystemRadius * 0.5, solarSystemRadius * 0.4, solarSystemRadius * 0.5);
                log('Cámara creada ✓', 'success');
            }
            
            function createRenderer() {
                log('Creando renderer...', 'info');
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                log('Renderer creado ✓', 'success');
            }
            
            function createPostProcessing() {
                log('Creando post-procesamiento...', 'info');
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);
                
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    0.8, 0.6, 0.7
                );
                composer.addPass(bloomPass);
                log('Post-procesamiento creado ✓', 'success');
            }
            
            function createStarField() {
                log('Creando campo de estrellas de fondo...', 'info');
                const starFieldGeo = new THREE.BufferGeometry();
                const starFieldCount = 8000;
                const positions = new Float32Array(starFieldCount * 3);
                for (let i = 0; i < starFieldCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 600;
                }
                starFieldGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const starFieldMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
                const starField = new THREE.Points(starFieldGeo, starFieldMaterial);
                scene.add(starField);
                log('Campo de estrellas creado ✓', 'success');
            }

            function createStar() {
                log('Creando estrella central con shaders...', 'info');
                
                // Crear campo de estrellas de fondo primero
                createStarField();
                
                // Obtener shaders del DOM
                const starVertexShader = document.getElementById('starVertexShader').textContent;
                const starFragmentShader = document.getElementById('starFragmentShader').textContent;
                
                const starGeo = new THREE.IcosahedronGeometry(2.2, 2);
                const starMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        intensity: { value: 1.0 },
                        color1: { value: new THREE.Color(themes[currentTheme].star) },
                        color2: { value: new THREE.Color(themes[currentTheme].star).multiplyScalar(0.7) }
                    },
                    vertexShader: starVertexShader,
                    fragmentShader: starFragmentShader
                });
                
                star = new THREE.Mesh(starGeo, starMaterial);
                scene.add(star);
                log('Estrella con shaders creada ✓', 'success');
            }
            
            function createTextSprite(text, color = '#ffffff') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Limpiar el canvas con fondo transparente
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'bold 24px Arial';
                context.fillStyle = color;
                context.strokeStyle = '#000000';
                context.lineWidth = 1.5; // Reducir grosor del borde
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Dibujar el borde primero (más delgado)
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                // Luego el relleno
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1 // Mejorar transparencia
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(3.5, 0.9, 1); // Ajustar escala
                
                return sprite;
            }
            
            function createPlanets() {
                log('Creando planetas con shaders...', 'info');
                
                const planetVertexShader = document.getElementById('planetVertexShader').textContent;
                const planetFragmentShader = document.getElementById('planetFragmentShader').textContent;
                
                const planetData = [
                    { size: 0.6, distance: 8, speed: 0.6, name: 'Mercurio' },
                    { size: 0.9, distance: 14, speed: 0.35, name: 'Venus' },
                    { size: 0.7, distance: 22, speed: 0.25, name: 'Tierra', moons: [{ size: 0.15, distance: 1.2, speed: 2.0, name: 'Luna' }] },
                    { size: 0.8, distance: 30, speed: 0.18, name: 'Marte', moons: [{ size: 0.08, distance: 1.0, speed: 2.5, name: 'Fobos' }, { size: 0.06, distance: 1.3, speed: 1.8, name: 'Deimos' }] },
                    { size: 0.5, distance: 38, speed: 0.12, name: 'Júpiter', moons: [{ size: 0.12, distance: 1.5, speed: 1.8, name: 'Ío' }, { size: 0.11, distance: 1.8, speed: 1.4, name: 'Europa' }, { size: 0.13, distance: 2.2, speed: 1.0, name: 'Ganímedes' }, { size: 0.12, distance: 2.6, speed: 0.8, name: 'Calisto' }] },
                    { size: 0.6, distance: 46, speed: 0.08, name: 'Saturno', moons: [{ size: 0.10, distance: 1.4, speed: 2.2, name: 'Titan' }, { size: 0.08, distance: 1.1, speed: 2.8, name: 'Encélado' }] },
                    { size: 0.4, distance: 54, speed: 0.06, name: 'Urano', moons: [{ size: 0.09, distance: 1.3, speed: 1.5, name: 'Miranda' }, { size: 0.08, distance: 1.6, speed: 1.2, name: 'Ariel' }] }
                ];
                
                planetData.forEach((data, i) => {
                    const planetGeo = new THREE.SphereGeometry(data.size, 32, 32);
                    const planetMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            baseColor: { value: new THREE.Color(themes[currentTheme].planets[i]) },
                            accentColor: { value: new THREE.Color(themes[currentTheme].planets[i]).multiplyScalar(1.5) },
                            energy: { value: 0.0 }
                        },
                        vertexShader: planetVertexShader,
                        fragmentShader: planetFragmentShader
                    });
                    
                    const planet = new THREE.Mesh(planetGeo, planetMaterial);
                    planet.position.x = data.distance;
                    planet.castShadow = true;
                    planet.receiveShadow = true;
                    scene.add(planet);
                    
                    // Crear etiqueta con el nombre del planeta
                    const label = createTextSprite(data.name, '#ffffff');
                    label.position.set(data.distance, data.size + 1.5, 0);
                    scene.add(label);
                    
                    // Guardar referencia a la etiqueta para actualizarla después
                    planet.userData = { label: label };
                    
                    // Crear órbita
                    const orbitGeo = new THREE.RingGeometry(data.distance - 0.1, data.distance + 0.1, 128);
                    const orbitMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x88ccff, 
                        transparent: true, 
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    const orbit = new THREE.Mesh(orbitGeo, orbitMaterial);
                    orbit.rotation.x = Math.PI / 2;
                    scene.add(orbit);
                    
                    // Crear lunas si el planeta las tiene
                    const moons = [];
                    if (data.moons) {
                        data.moons.forEach((moonData, moonIndex) => {
                            const moonGeo = new THREE.SphereGeometry(moonData.size, 16, 16);
                            
                            // Colores realistas para las lunas principales
                            let moonColor = 0xaaaaaa; // Gris por defecto
                            if (data.name === 'Tierra') {
                                moonColor = 0x8c8c8c; // Luna - gris claro
                            } else if (data.name === 'Marte') {
                                moonColor = moonData.name === 'Fobos' ? 0x8b7355 : 0x696969; // Fobos marrón, Deimos gris oscuro
                            } else if (data.name === 'Júpiter') {
                                if (moonData.name === 'Ío') moonColor = 0xffff99; // Ío - amarillo sulfuroso
                                else if (moonData.name === 'Europa') moonColor = 0xadd8e6; // Europa - azul hielo
                                else if (moonData.name === 'Ganímedes') moonColor = 0x8fbc8f; // Ganímedes - verde grisáceo
                                else if (moonData.name === 'Calisto') moonColor = 0x696969; // Calisto - gris oscuro
                            } else if (data.name === 'Saturno') {
                                if (moonData.name === 'Titan') moonColor = 0xdaa520; // Titan - oro oscuro (atmósfera)
                                else if (moonData.name === 'Encélado') moonColor = 0xf0f8ff; // Encélado - blanco hielo
                            } else if (data.name === 'Urano') {
                                moonColor = 0xc0c0c0; // Gris plata para lunas de Urano
                            }
                            
                            const moonMaterial = new THREE.MeshBasicMaterial({ 
                                color: moonColor,
                                transparent: true,
                                opacity: 0.85
                            });
                            const moon = new THREE.Mesh(moonGeo, moonMaterial);
                            moon.castShadow = true;
                            moon.receiveShadow = true;
                            scene.add(moon);
                            
                            moons.push({
                                mesh: moon,
                                distance: moonData.distance,
                                speed: moonData.speed,
                                angle: Math.random() * Math.PI * 2,
                                material: moonMaterial,
                                name: moonData.name
                            });
                            
                            log(`Luna ${moonData.name} de ${data.name} creada ✓`, 'success');
                        });
                    }
                    
                    planets.push({
                        mesh: planet,
                        distance: data.distance,
                        speed: data.speed,
                        angle: Math.random() * Math.PI * 2,
                        material: planetMaterial,
                        moons: moons
                    });
                    
                    log(`Planeta ${data.name} con shader creado ✓`, 'success');
                });
                log('Planetas con shaders creados ✓', 'success');
            }
            
            function createLighting() {
                log('Creando iluminación...', 'info');
                const ambientLight = new THREE.AmbientLight(themes[currentTheme].ambient, 0.8);
                scene.add(ambientLight);
                
                const starLight = new THREE.PointLight(themes[currentTheme].point, 3, 120, 1.8);
                starLight.castShadow = true;
                scene.add(starLight);
                log('Iluminación creada ✓', 'success');
            }
            
            function createControls() {
                log('Creando controles...', 'info');
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.03;
                controls.minDistance = 15;
                controls.maxDistance = 200;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.1;
                log('Controles creados ✓', 'success');
            }
            
            function createComets() {
                log('Creando cometas...', 'info');
                for (let i = 0; i < 5; i++) {
                    const cometGeo = new THREE.SphereGeometry(0.15, 8, 8);
                    const cometMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const comet = new THREE.Mesh(cometGeo, cometMaterial);
                    
                    comet.position.set(
                        (Math.random() - 0.5) * 120,
                        (Math.random() - 0.5) * 120,
                        (Math.random() - 0.5) * 120
                    );
                    
                    scene.add(comet);
                    comets.push({
                        mesh: comet,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.8,
                            (Math.random() - 0.5) * 0.8,
                            (Math.random() - 0.5) * 0.8
                        )
                    });
                }
                log('Cometas creados ✓', 'success');
            }
            
            // La función createSpaceship ha sido eliminada del sistema
            
            function createBigBangEffect() {
                log('Creando efecto Big Bang...', 'info');
                
                const bigBangVertexShader = document.getElementById('bigBangVertexShader').textContent;
                const bigBangFragmentShader = document.getElementById('bigBangFragmentShader').textContent;
                
                const bigBangGeo = new THREE.SphereGeometry(80, 64, 64);
                const bigBangMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        center: { value: new THREE.Vector3(0, 0, 0) },
                        explosionRadius: { value: 50.0 }
                    },
                    vertexShader: bigBangVertexShader,
                    fragmentShader: bigBangFragmentShader,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                bigBangEffect = new THREE.Mesh(bigBangGeo, bigBangMaterial);
                bigBangEffect.visible = false;
                scene.add(bigBangEffect);
                log('Efecto Big Bang creado ✓', 'success');
            }
            
            function activateBigBang() {
                log('¡ACTIVANDO BIG BANG!', 'warning');
                bigBangEffect.visible = true;
                bigBangEffect.material.uniforms.time.value = 0;
                
                // Animar el efecto
                let bigBangTime = 0;
                const bigBangDuration = 5; // segundos
                
                function animateBigBang() {
                    bigBangTime += 0.016;
                    bigBangEffect.material.uniforms.time.value = bigBangTime;
                    
                    if (bigBangTime < bigBangDuration) {
                        requestAnimationFrame(animateBigBang);
                    } else {
                        bigBangEffect.visible = false;
                        log('Efecto Big Bang completado ✓', 'success');
                    }
                }
                
                animateBigBang();
            }
            
            function setupEventListeners() {
                log('Configurando event listeners...', 'info');
                
                window.addEventListener('resize', onWindowResize);
                
                // Event listeners para los botones
                document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('activateTrigger').addEventListener('click', activateResonance);
            document.getElementById('timeAccel').addEventListener('click', toggleTimeAcceleration);
            document.getElementById('toggleTheme').addEventListener('click', toggleTheme);
                
                log('Event listeners configurados ✓', 'success');
            }
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (composer) {
                    composer.setSize(window.innerWidth, window.innerHeight);
                }
            }
            
            function resetView() {
                camera.position.set(35, 28, 35);
                camera.lookAt(0, 0, 0);
                controls.reset();
                log('Vista reiniciada ✓', 'info');
            }
            
            function toggleTheme() {
                const themeNames = Object.keys(themes);
                const currentIndex = themeNames.indexOf(currentTheme);
                currentTheme = themeNames[(currentIndex + 1) % themeNames.length];
                
                // Actualizar colores
                scene.background = new THREE.Color(themes[currentTheme].background);
                star.material.uniforms.color1.value = new THREE.Color(themes[currentTheme].star);
                star.material.uniforms.color2.value = new THREE.Color(themes[currentTheme].star).multiplyScalar(0.7);
                
                planets.forEach((p, i) => {
                    p.material.uniforms.baseColor.value = new THREE.Color(themes[currentTheme].planets[i]);
                    p.material.uniforms.accentColor.value = new THREE.Color(themes[currentTheme].planets[i]).multiplyScalar(1.5);
                    
                    // Actualizar color de las lunas (mantener colores realistas)
                    if (p.moons) {
                        p.moons.forEach(moon => {
                            // No cambiar los colores realistas de las lunas
                            // Solo ajustar la opacidad para que se vean bien con el nuevo tema
                            moon.material.opacity = 0.85;
                        });
                    }
                });
                
                // Actualizar texto del botón
                document.getElementById('toggleTheme').textContent = `Theme: ${currentTheme}`;
                
                log(`Tema cambiado a: ${currentTheme} ✓`, 'info');
            }
            
            function activateResonance() {
                // Si la resonancia ya está activa, no hacer nada
                if (resonanceActive) return;
                
                resonanceActive = true;
                log('Resonancia activada ✓', 'info');
                
                // Efecto temporal en el botón (sin mantener estado)
                const activateButton = document.getElementById('activateTrigger');
                
                // Añadir clase temporalmente para efecto visual
                activateButton.classList.add('resonance-active');
                
                // Remover clase después de 300ms para efecto de clic
                setTimeout(() => {
                    activateButton.classList.remove('resonance-active');
                }, 300);
                
                // Crear efectos de resonancia
                createEnhancedResonanceEffects();
                
                // Auto-desactivar después de 5 segundos
                setTimeout(() => {
                    if (resonanceActive) {
                        resonanceActive = false;
                        clearResonanceEffects();
                        log('Resonancia auto-desactivada ✓', 'info');
                    }
                }, 5000);
                
                // Efecto visual de resonancia mejorado
                planets.forEach(p => {
                    p.material.uniforms.energy.value = 2.0;
                    
                    // Efecto de escala y pulso en planetas
                    p.body.userData.originalScale = p.body.scale.clone();
                    p.body.userData.pulsePhase = Math.random() * Math.PI * 2;
                    
                    // Efecto en las lunas
                    if (p.moons) {
                        p.moons.forEach(moon => {
                            // Efecto de resonancia con colores específicos para cada luna
                            if (moon.name === 'Luna') {
                                moon.material.color = new THREE.Color(0xffffff); // Blanco brillante para la Luna
                            } else if (moon.name === 'Fobos' || moon.name === 'Deimos') {
                                moon.material.color = new THREE.Color(0xff8c69); // Naranja rojizo para lunas marcianas
                            } else if (moon.name === 'Ío') {
                                moon.material.color = new THREE.Color(0xffff99); // Amarillo brillante para Ío
                            } else if (moon.name === 'Europa') {
                                moon.material.color = new THREE.Color(0x87ceeb); // Azul cielo para Europa
                            } else if (moon.name === 'Titan') {
                                moon.material.color = new THREE.Color(0xffa500); // Naranja para Titan
                            } else if (moon.name === 'Encélado') {
                                moon.material.color = new THREE.Color(0xf0f8ff); // Blanco azulado para Encélado
                            } else {
                                moon.material.color = new THREE.Color(0x87ceeb); // Azul por defecto
                            }
                            moon.material.opacity = 1.0;
                            moon.userData.resonanceGlow = true;
                        });
                    }
                });
                
                star.material.uniforms.intensity.value = 3.0;
            }
            
            function createEnhancedResonanceEffects() {
                // Rayos eléctricos entre planetas
                createElectricRays();
            }
            
            function clearResonanceEffects() {
                // Limpiar efectos especiales
                resonanceEffects.forEach(effect => {
                    if (effect.mesh) scene.remove(effect.mesh);
                    if (effect.geometry) effect.geometry.dispose();
                    if (effect.material) effect.material.dispose();
                });
                resonanceEffects = [];
                
                // Restaurar iluminación normal
                ambientLight.intensity = 0.4;
                if (camera.userData.originalPosition) {
                    camera.position.copy(camera.userData.originalPosition);
                }
            }
            
            // Variables globales para efectos de resonancia
            let resonanceEffects = [];
            
            function createShockWave() {
                // Onda de choque expansiva
                const geometry = new THREE.RingGeometry(0.1, 50, 64);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                const shockWave = new THREE.Mesh(geometry, material);
                shockWave.position.copy(star.position);
                shockWave.rotation.x = Math.PI / 2;
                scene.add(shockWave);
                
                const effect = {
                    mesh: shockWave,
                    material: material,
                    geometry: geometry,
                    startTime: Date.now(),
                    duration: 3000,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        const progress = elapsed / this.duration;
                        
                        if (progress >= 1) {
                            scene.remove(this.mesh);
                            this.geometry.dispose();
                            this.material.dispose();
                            return false;
                        }
                        
                        const scale = 1 + progress * 20;
                        this.mesh.scale.setScalar(scale);
                        this.material.opacity = (1 - progress) * 0.8;
                        this.material.color.setHSL(0.5 + progress * 0.3, 1, 0.5);
                        
                        return true;
                    }
                };
                
                resonanceEffects.push(effect);
            }
            
            function createEnergySpiral() {
                // Espiral de energía alrededor del sistema
                const points = [];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const radius = 5 + t * 20;
                    const height = t * 15 - 7.5;
                    const angle = t * Math.PI * 4;
                    
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    ));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 200, 0.3, 8, false);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const spiral = new THREE.Mesh(geometry, material);
                scene.add(spiral);
                
                const effect = {
                    mesh: spiral,
                    material: material,
                    geometry: geometry,
                    startTime: Date.now(),
                    duration: 5000,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        const progress = elapsed / this.duration;
                        
                        if (progress >= 1) {
                            scene.remove(this.mesh);
                            this.geometry.dispose();
                            this.material.dispose();
                            return false;
                        }
                        
                        this.mesh.rotation.y += 0.03;
                        this.mesh.rotation.x += 0.01;
                        this.material.opacity = (1 - progress) * 0.8;
                        this.material.color.setHSL(progress * 0.8, 1, 0.5);
                        
                        return true;
                    }
                };
                
                resonanceEffects.push(effect);
            }
            
            function createParticleStorm() {
                // Tormenta de partículas energéticas
                const particleCount = 1500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const radius = Math.random() * 50 + 10;
                    const angle = Math.random() * Math.PI * 2;
                    const height = (Math.random() - 0.5) * 30;
                    
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = height;
                    positions[i3 + 2] = Math.sin(angle) * radius;
                    
                    colors[i3] = Math.random();
                    colors[i3 + 1] = Math.random();
                    colors[i3 + 2] = Math.random();
                    
                    velocities[i3] = (Math.random() - 0.5) * 0.2;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.2;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(geometry, material);
                scene.add(particles);
                
                const effect = {
                    mesh: particles,
                    material: material,
                    geometry: geometry,
                    startTime: Date.now(),
                    duration: 6000,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        const progress = elapsed / this.duration;
                        
                        if (progress >= 1) {
                            scene.remove(this.mesh);
                            this.geometry.dispose();
                            this.material.dispose();
                            return false;
                        }
                        
                        const positions = this.geometry.attributes.position.array;
                        const velocities = this.geometry.attributes.velocity.array;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += velocities[i];
                            positions[i + 1] += velocities[i + 1];
                            positions[i + 2] += velocities[i + 2];
                            
                            // Aplicar fuerza hacia el centro
                            const dx = -positions[i];
                            const dz = -positions[i + 2];
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            if (distance > 0) {
                                velocities[i] += dx / distance * 0.001;
                                velocities[i + 2] += dz / distance * 0.001;
                            }
                        }
                        
                        this.geometry.attributes.position.needsUpdate = true;
                        this.material.opacity = (1 - progress) * 0.9;
                        this.mesh.rotation.y += 0.02;
                        
                        return true;
                    }
                };
                
                resonanceEffects.push(effect);
            }
            
            function createCameraShake() {
                // Efecto de sacudida de cámara cinematográfica
                if (!camera.userData.originalPosition) {
                    camera.userData.originalPosition = camera.position.clone();
                }
                
                const shakeIntensity = 0.8;
                const shakeDuration = 4000;
                const startTime = Date.now();
                
                function shake() {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / shakeDuration;
                    
                    if (progress >= 1) {
                        camera.position.copy(camera.userData.originalPosition);
                        return;
                    }
                    
                    const intensity = shakeIntensity * (1 - progress);
                    const frequency = 0.1;
                    
                    camera.position.x = camera.userData.originalPosition.x + Math.sin(elapsed * frequency) * intensity;
                    camera.position.y = camera.userData.originalPosition.y + Math.cos(elapsed * frequency * 1.3) * intensity * 0.5;
                    camera.position.z = camera.userData.originalPosition.z + Math.sin(elapsed * frequency * 0.7) * intensity * 0.8;
                    
                    requestAnimationFrame(shake);
                }
                
                shake();
            }
            
            function createStrobeLighting() {
                // Iluminación estroboscópica dinámica
                const startTime = Date.now();
                const duration = 5000;
                const originalIntensity = ambientLight.intensity;
                
                function strobe() {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress >= 1) {
                        ambientLight.intensity = originalIntensity;
                        return;
                    }
                    
                    const strobeFreq = 0.05; // Frecuencia del estroboscopio
                    const intensity = originalIntensity + Math.sin(elapsed * strobeFreq) * 0.8;
                    ambientLight.intensity = Math.max(0.1, intensity);
                    
                    // Cambiar colores de las luces dinámicamente
                    const hue = (elapsed * 0.001) % 1;
                    blueLight.color.setHSL(hue, 1, 0.5);
                    purpleLight.color.setHSL((hue + 0.5) % 1, 1, 0.5);
                    
                    requestAnimationFrame(strobe);
                }
                
                strobe();
            }
            
            function createResonanceWaves() {
                // Múltiples ondas de resonancia concéntricas
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.7,
                            wireframe: true
                        });
                        
                        const wave = new THREE.Mesh(geometry, material);
                        wave.position.copy(star.position);
                        scene.add(wave);
                        
                        const effect = {
                            mesh: wave,
                            material: material,
                            geometry: geometry,
                            startTime: Date.now(),
                            duration: 2500,
                            update: function() {
                                const elapsed = Date.now() - this.startTime;
                                const progress = elapsed / this.duration;
                                
                                if (progress >= 1) {
                                    scene.remove(this.mesh);
                                    this.geometry.dispose();
                                    this.material.dispose();
                                    return false;
                                }
                                
                                const scale = 1 + progress * 25;
                                this.mesh.scale.setScalar(scale);
                                this.material.opacity = (1 - progress) * 0.7;
                                this.material.color.setHSL(0.5 + progress * 0.4, 1, 0.5);
                                
                                return true;
                            }
                        };
                        
                        resonanceEffects.push(effect);
                    }, i * 300);
                }
            }
            
            function createPlanetConnections() {
                // Crear líneas energéticas entre planetas cercanos
                const connectionMaterial = new THREE.LineBasicMaterial({
                    color: 0x4488ff,
                    transparent: true,
                    opacity: 0.4
                });
                
                // Conectar planetas cercanos
                for (let i = 0; i < planets.length; i++) {
                    for (let j = i + 1; j < planets.length; j++) {
                        const planet1 = planets[i];
                        const planet2 = planets[j];
                        
                        // Solo conectar planetas que están relativamente cerca
                        const distance = planet1.mesh.position.distanceTo(planet2.mesh.position);
                        if (distance < 30) {
                            const points = [
                                planet1.mesh.position.clone(),
                                planet2.mesh.position.clone()
                            ];
                            
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, connectionMaterial);
                            scene.add(line);
                            
                            const effect = {
                                mesh: line,
                                material: connectionMaterial,
                                geometry: geometry,
                                startTime: Date.now(),
                                duration: 8000,
                                planet1: planet1.mesh,
                                planet2: planet2.mesh,
                                update: function() {
                                    const elapsed = Date.now() - this.startTime;
                                    const progress = elapsed / this.duration;
                                    
                                    if (progress >= 1) {
                                        scene.remove(this.mesh);
                                        this.geometry.dispose();
                                        return false;
                                    }
                                    
                                    // Actualizar posiciones de las líneas
                                    const points = [
                                        this.planet1.position.clone(),
                                        this.planet2.position.clone()
                                    ];
                                    this.geometry.setFromPoints(points);
                                    
                                    // Efecto de pulso en la opacidad
                                    const pulse = 0.2 + Math.sin(elapsed * 0.005) * 0.2;
                                    this.material.opacity = pulse;
                                    
                                    // Cambiar color suavemente
                                    const hue = (elapsed * 0.0001) % 1;
                                    this.material.color.setHSL(hue, 0.7, 0.6);
                                    
                                    return true;
                                }
                            };
                            
                            resonanceEffects.push(effect);
                        }
                    }
                }
            }
            
            function createEnergyFlow() {
                // Crear partículas que fluyen entre planetas
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    // Distribuir partículas entre planetas
                    const planetIndex = Math.floor(Math.random() * planets.length);
                    const planet = planets[planetIndex];
                    
                    positions[i * 3] = planet.mesh.position.x + (Math.random() - 0.5) * 5;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 2] = planet.mesh.position.z + (Math.random() - 0.5) * 5;
                    
                    colors[i * 3] = 0.3 + Math.random() * 0.7;
                    colors[i * 3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i * 3 + 2] = 1.0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(geometry, material);
                scene.add(particles);
                
                const effect = {
                    mesh: particles,
                    material: material,
                    geometry: geometry,
                    startTime: Date.now(),
                    duration: 10000,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        const progress = elapsed / this.duration;
                        
                        if (progress >= 1) {
                            scene.remove(this.mesh);
                            this.geometry.dispose();
                            this.material.dispose();
                            return false;
                        }
                        
                        const positions = this.geometry.attributes.position.array;
                        const colors = this.geometry.attributes.color.array;
                        
                        // Mover partículas suavemente entre planetas
                        for (let i = 0; i < positions.length; i += 9) { // Procesar en grupos de 3 partículas
                            const planetIndex = Math.floor((i / 9) % planets.length);
                            const planet = planets[planetIndex];
                            const nextPlanetIndex = (planetIndex + 1) % planets.length;
                            const nextPlanet = planets[nextPlanetIndex];
                            
                            if (planet && nextPlanet) {
                                const t = (elapsed * 0.0005 + i * 0.01) % 1;
                                const x = planet.mesh.position.x * (1 - t) + nextPlanet.mesh.position.x * t;
                                const z = planet.mesh.position.z * (1 - t) + nextPlanet.mesh.position.z * t;
                                
                                positions[i] = x + Math.sin(elapsed * 0.003 + i) * 2;
                                positions[i + 1] = Math.sin(elapsed * 0.002 + i) * 1;
                                positions[i + 2] = z + Math.cos(elapsed * 0.003 + i) * 2;
                                
                                // Efecto de color pulsante
                                const pulse = 0.5 + Math.sin(elapsed * 0.004 + i) * 0.5;
                                colors[i] = pulse;
                                colors[i + 1] = pulse * 0.8;
                                colors[i + 2] = 1.0;
                            }
                        }
                        
                        this.geometry.attributes.position.needsUpdate = true;
                        this.geometry.attributes.color.needsUpdate = true;
                        this.material.opacity = 0.4 + Math.sin(elapsed * 0.002) * 0.2;
                        
                        return true;
                    }
                };
                
                resonanceEffects.push(effect);
            }
            
            function createSubtleGlow() {
                // Resplandor sutil alrededor de la estrella
                const geometry = new THREE.SphereGeometry(2, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x88ccff,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                
                const glow = new THREE.Mesh(geometry, material);
                glow.position.copy(star.position);
                scene.add(glow);
                
                const effect = {
                    mesh: glow,
                    material: material,
                    geometry: geometry,
                    startTime: Date.now(),
                    duration: 12000,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        const progress = elapsed / this.duration;
                        
                        if (progress >= 1) {
                            scene.remove(this.mesh);
                            this.geometry.dispose();
                            this.material.dispose();
                            return false;
                        }
                        
                        // Efecto de respiración sutil
                        const breathe = 1 + Math.sin(elapsed * 0.001) * 0.3;
                        this.mesh.scale.setScalar(breathe);
                        
                        // Opacidad muy sutil
                        this.material.opacity = 0.1 + Math.sin(elapsed * 0.0008) * 0.1;
                        
                        // Rotación lenta
                        this.mesh.rotation.y += 0.005;
                        this.mesh.rotation.x += 0.003;
                        
                        return true;
                    }
                };
                
                resonanceEffects.push(effect);
            }
            
            function createPlanetaryWaves() {
                // Crear ondas concéntricas desde cada planeta como piedras en el agua
                planets.forEach((planet, planetIndex) => {
                    // Crear múltiples ondas por cada planeta
                    for (let waveIndex = 0; waveIndex < 4; waveIndex++) {
                        setTimeout(() => {
                            // Crear geometría de anillo para la onda
                            const geometry = new THREE.RingGeometry(0.1, 1, 64);
                            const material = new THREE.MeshBasicMaterial({
                                color: planet.color || 0x4488ff,
                                transparent: true,
                                opacity: 0.6,
                                side: THREE.DoubleSide
                            });
                            
                            const wave = new THREE.Mesh(geometry, material);
                            wave.position.copy(planet.mesh.position);
                            wave.rotation.x = Math.PI / 2; // Orientar horizontalmente
                            scene.add(wave);
                            
                            const effect = {
                                mesh: wave,
                                material: material,
                                geometry: geometry,
                                startTime: Date.now(),
                                duration: 3000,
                                planet: planet.mesh,
                                update: function() {
                                    const elapsed = Date.now() - this.startTime;
                                    const progress = elapsed / this.duration;
                                    
                                    if (progress >= 1) {
                                        scene.remove(this.mesh);
                                        this.geometry.dispose();
                                        this.material.dispose();
                                        return false;
                                    }
                                    
                                    // Actualizar posición para seguir al planeta
                                    this.mesh.position.copy(this.planet.position);
                                    
                                    // Expandir la onda como en el agua
                                    const scale = 1 + progress * 8; // Expandir 8 veces su tamaño
                                    this.mesh.scale.setScalar(scale);
                                    
                                    // Desvanecer la opacidad
                                    this.material.opacity = (1 - progress) * 0.6;
                                    
                                    // Cambiar color suavemente
                                    const hue = (elapsed * 0.0005) % 1;
                                    this.material.color.setHSL(hue, 0.7, 0.6);
                                    
                                    // Rotar ligeramente para efecto dinámico
                                    this.mesh.rotation.z += 0.01;
                                    
                                    return true;
                                }
                            };
                            
                            resonanceEffects.push(effect);
                        }, waveIndex * 500); // Espaciar las ondas en el tiempo
                    }
                });
            }
            
            function createStellarPulse() {
                // Pulso de energía desde la estrella central que alcanza el último planeta
                // Calcular la distancia máxima al último planeta
                const maxDistance = planets.length > 0 ? 
                    Math.max(...planets.map(p => p.mesh.position.distanceTo(star.position))) : 30;
                
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const geometry = new THREE.RingGeometry(0.5, 2, 64);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0xffff00,
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide
                        });
                        
                        const pulse = new THREE.Mesh(geometry, material);
                        pulse.position.copy(star.position);
                        pulse.rotation.x = Math.PI / 2;
                        scene.add(pulse);
                        
                        const effect = {
                            mesh: pulse,
                            material: material,
                            geometry: geometry,
                            startTime: Date.now(),
                            duration: 3000,
                            maxDistance: maxDistance,
                            update: function() {
                                const elapsed = Date.now() - this.startTime;
                                const progress = elapsed / this.duration;
                                
                                if (progress >= 1) {
                                    scene.remove(this.mesh);
                                    this.geometry.dispose();
                                    this.material.dispose();
                                    return false;
                                }
                                
                                // Pulso suave y fluido sin efecto de cuadros
                                const easeProgress = 1 - Math.pow(1 - progress, 3); // Easing cúbico para suavidad
                                const maxScale = this.maxDistance / 1.5; // Escalar para alcanzar el último planeta
                                const scale = 1 + easeProgress * maxScale;
                                const opacity = (1 - easeProgress) * 0.7; // Desvanecimiento suave
                                
                                this.mesh.scale.setScalar(scale);
                                this.material.opacity = Math.max(0, opacity);
                                
                                // Cambio de color suave del amarillo al rojo
                                const hue = 0.15 + easeProgress * 0.12;
                                const saturation = 0.8 + easeProgress * 0.2;
                                const lightness = 0.5 + Math.sin(easeProgress * Math.PI) * 0.2;
                                this.material.color.setHSL(hue, saturation, lightness);
                                
                                return true;
                            }
                        };
                        
                        resonanceEffects.push(effect);
                    }, i * 500);
                }
            }
            
            function createElectricRays() {
                // Rayos eléctricos realistas conectando todos los planetas
                const rayMaterial = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.9,
                    linewidth: 3
                });
                
                // Crear rayos entre todos los planetas (no solo adyacentes)
                for (let i = 0; i < planets.length; i++) {
                    for (let j = i + 1; j < planets.length; j++) {
                        const planet1 = planets[i];
                        const planet2 = planets[j];
                        
                        // Crear rayo con segmentos para efecto eléctrico
                        const segments = 8;
                        const points = [];
                        const startPos = planet1.mesh.position.clone();
                        const endPos = planet2.mesh.position.clone();
                        
                        // Generar puntos intermedios con desviación aleatoria para efecto eléctrico
                        for (let s = 0; s <= segments; s++) {
                            const t = s / segments;
                            const point = startPos.clone().lerp(endPos, t);
                            
                            // Añadir desviación eléctrica
                            const deviation = Math.sin(t * Math.PI * 4) * 0.5;
                            point.x += (Math.random() - 0.5) * deviation;
                            point.y += (Math.random() - 0.5) * deviation;
                            point.z += (Math.random() - 0.5) * deviation;
                            
                            points.push(point);
                        }
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const ray = new THREE.Line(geometry, rayMaterial.clone());
                        scene.add(ray);
                        
                        const effect = {
                            mesh: ray,
                            material: ray.material,
                            geometry: geometry,
                            startTime: Date.now(),
                            duration: 2000,
                            planet1: planet1.mesh,
                            planet2: planet2.mesh,
                            originalPoints: points.map(p => p.clone()),
                            update: function() {
                                const elapsed = Date.now() - this.startTime;
                                const progress = elapsed / this.duration;
                                
                                if (progress >= 1) {
                                    scene.remove(this.mesh);
                                    this.geometry.dispose();
                                    this.material.dispose();
                                    return false;
                                }
                                
                                // Actualizar posiciones siguiendo a los planetas
                                const startPos = this.planet1.position.clone();
                                const endPos = this.planet2.position.clone();
                                
                                // Regenerar puntos con nueva desviación eléctrica
                                const newPoints = [];
                                const segments = 8;
                                
                                for (let s = 0; s <= segments; s++) {
                                    const t = s / segments;
                                    const point = startPos.clone().lerp(endPos, t);
                                    
                                    // Desviación eléctrica dinámica
                                    const deviation = Math.sin(t * Math.PI * 4 + elapsed * 0.01) * 0.3;
                                    point.x += (Math.random() - 0.5) * deviation;
                                    point.y += (Math.random() - 0.5) * deviation;
                                    point.z += (Math.random() - 0.5) * deviation;
                                    
                                    newPoints.push(point);
                                }
                                
                                this.geometry.setFromPoints(newPoints);
                                
                                // Efecto de parpadeo eléctrico
                                const flicker = 0.6 + Math.sin(elapsed * 0.02) * 0.4;
                                this.material.opacity = flicker;
                                
                                // Color eléctrico con variación
                                const hue = 0.5 + Math.sin(elapsed * 0.005) * 0.1;
                                this.material.color.setHSL(hue, 1, 0.6);
                                
                                return true;
                            }
                        };
                        
                        resonanceEffects.push(effect);
                    }
                }
            }
            
            function toggleTimeAcceleration() {
                if (timeAcceleration === 1) {
                    timeAcceleration = 2;
                } else if (timeAcceleration === 2) {
                    timeAcceleration = 5;
                } else if (timeAcceleration === 5) {
                    timeAcceleration = 10;
                } else if (timeAcceleration === 10) {
                    timeAcceleration = 0.5;
                } else {
                    timeAcceleration = 1;
                }
                document.getElementById('timeAccel').textContent = `Time: ${timeAcceleration}x`;
                log(`Velocidad del tiempo: ${timeAcceleration}x ✓`, 'info');
            }
            
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta() * timeAcceleration;
                const t = clock.getElapsedTime();
                
                // Actualizar shaders
                if (star) {
                    star.material.uniforms.time.value = t;
                }
                
                planets.forEach(p => {
                    p.material.uniforms.time.value = t;
                    p.angle += delta * p.speed;
                    p.mesh.position.x = Math.cos(p.angle) * p.distance;
                    p.mesh.position.z = Math.sin(p.angle) * p.distance;
                    p.mesh.rotation.y += delta * 0.6;
                    
                    // Actualizar posición de la etiqueta para que siga al planeta
                    if (p.mesh.userData.label) {
                        p.mesh.userData.label.position.set(
                            p.mesh.position.x,
                            p.mesh.position.y + p.mesh.geometry.parameters.radius + 1.5,
                            p.mesh.position.z
                        );
                    }
                    
                    // Efecto de pulso en planetas durante resonancia
                    if (resonanceActive && p.mesh.userData.originalScale) {
                        const pulseScale = 1 + Math.sin(t * 3 + p.mesh.userData.pulsePhase) * 0.3;
                        p.mesh.scale.copy(p.mesh.userData.originalScale).multiplyScalar(pulseScale);
                    }
                    
                    // Actualizar posición de las lunas
                    if (p.moons) {
                        p.moons.forEach(moon => {
                            moon.angle += delta * moon.speed;
                            // Posición relativa al planeta
                            const moonX = p.mesh.position.x + Math.cos(moon.angle) * moon.distance;
                            const moonZ = p.mesh.position.z + Math.sin(moon.angle) * moon.distance;
                            moon.mesh.position.set(moonX, 0, moonZ);
                            
                            // Efecto de rotación adicional en lunas durante resonancia
                            if (resonanceActive && moon.mesh.userData.resonanceGlow) {
                                moon.mesh.rotation.y += delta * 0.5;
                                moon.mesh.rotation.x += delta * 0.2;
                            }
                        });
                    }
                });
                
                // Animar cometas
                comets.forEach(c => {
                    c.mesh.position.add(c.velocity.clone().multiplyScalar(delta));
                    if (c.mesh.position.length() > 150) {
                        c.mesh.position.set(
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120
                        );
                    }
                });
                
                // Animación de naves espaciales eliminada del sistema
                
                // Naves y asteroides eliminados según solicitud del usuario
                
                // Actualizar efectos de resonancia
                resonanceEffects = resonanceEffects.filter(effect => effect.update());
                
                if (controls) controls.update();
                
                if (composer) {
                    composer.render();
                } else if (renderer) {
                    renderer.render(scene, camera);
                }
            }
            
            // Inicializar todo
            setState('Inicializando sistema completo...');
            createScene();
            createCamera();
            createRenderer();
            createPostProcessing();
            createStar();
            createPlanets();
            createLighting();
            createControls();
            createComets();
            // Las naves espaciales han sido eliminadas del sistema
            createBigBangEffect();
            setupEventListeners();
            
            // Naves y asteroides eliminados según solicitud del usuario
            
            // Funciones de naves y asteroides eliminadas según solicitud del usuario
            
            setState('¡GALAXIA COMPLETA FUNCIONANDO!');
            log('=== SISTEMA SOLAR 3D CON BIG BANG Y OBJETOS ESPACIALES INICIADO ===', 'success');
            
            // Iniciar animación
            animate();
            
        } catch (error) {
            setState('ERROR CRÍTICO');
            log('ERROR FATAL: ' + error.message, 'error');
            log('Stack: ' + error.stack, 'error');
            console.error('Error completo:', error);
        }
    </script>
</body>
</html>